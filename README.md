# Meeting Scheduler API

[![Java Version](https://img.shields.io/badge/Java-17-blue.svg)](https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html) [![Build Tool](https://img.shields.io/badge/Build-Maven-critical)](https://maven.apache.org/) [![License](https://img.shields.io/badge/License-Apache%202.0-green.svg)](https://opensource.org/licenses/Apache-2.0)

RESTful API для координации встреч, созданный на базе Java и Spring Boot. Приложение позволяет эффективно управлять планированием встреч благодаря функциям подбора времени, проверки на наличие конфликтов в расписании и контроля вместимости помещений.

---
## Оглавление

- [Стек технологий](#стек-технологий)
- [Обзор](#обзор)
- [Быстрый старт](#быстрый-старт)
- [Установка и конфигурация](#установка-и-конфигурация)
- [Контейнеризация (Docker)](#контейнеризация-docker)
- [Тестирование](#тестирование)
- [API документация](#api-документация)
- [Сценарий использования](#сценарий-использования)

---
## Стек Технологий

**Основной фреймворк: Java 21, Spring Boot 3.4** (современная LTS-версия с автоконфигурацией)

**Работа с данными: Spring Data JPA, Hibernate** (чистый ORM)

**База данных: PostgreSQL** (реляционная БД)

**Безопасность: Spring Security 6, JWT** (stateless-аутентификация с RBAC)

**Тестирование: JUnit 5, Mockito, Testcontainers** (многоуровневое тестирование)

**Сборка и развертывание: Maven, Docker** (контейнеризированная сборка)

**API документация: SpringDoc OpenAPI** (автогенерация Swagger UI)

**Утилиты: Lombok, Jakarta Bean Validation** (уменьшение шаблонного кода, валидация данных)

## Обзор

API управляет тремя основными сущностями: встречи, участники и локации. Он предотвращает конфликты при планировании встреч и контролирует соблюдение ограничений по вместимости помещений.

### Основной функционал

**Управление встречами:** Создание, чтение, обновление и удаление встреч с учетом временных конфликтов и ограничений по количеству участников.

**Предотвращение конфликтов:** Приложение анализирует расписание участников и забронированные локации, чтобы убедиться в отсутствии конфликтов по времени.

**Анализ доступности:** Предоставляет эндпоинты для проверки расписания нескольких участников и доступности локаций. Это позволяет предложить свободные временные интервалы, которые могут быть удобны для всех.

**Контроль вместимости:** Предотвращает превышение допустимой вместимости помещений и возвращает сообщения об ошибках при нарушениях.

**Аутентификация и авторизация:** В используются JWT-токены для аутентификации пользователя по учетным данным и управления доступом на основе ролей. Различные роли наделены разными правами, в том числе на создание новых участников и управление локациями.

**Валидация входных данных:** Проверка данных осуществляется на нескольких уровнях: при обращении к API, в рамках бизнес-логики и при соблюдении ограничений, заданных в базе данных. В случае выявления ошибок предоставляются подробные сообщения.

**Документация API:** Интерактивная документация, созданная автоматически с помощью SpringDoc OpenAPI.

### Планирование встреч

При создании встречи система выполняет следующие шаги:

1. Проверяет правильность всех данных о встрече, включая время, участников и локацию.
2. Убеждается, что выбранная локация свободна в назначенное время.
3. Убеждается, что участники не заняты на других встречах в это время.
4. Проверяет, сможет ли локация вместить всех заявленных участников.
5. Создает встречу, если все проверки пройдены успешно.

Функция подбора доступного времени работает путем анализа текущих расписаний и возврата свободных временных окон, когда доступны все указанные участники и желаемая локация.

### API эндпоинты

API предоставляет стандартные REST-эндпоинты для задач:

- Управления встречами (операции CRUD)
- Управления участниками и локациями
- Проверки доступности по расписанию
- Предложения оптимального времени

Все эндпоинты требуют корректной аутентификации, а некоторые операции ограничены в зависимости от ролей пользователей.

## Быстрый старт

1.  Убедитесь, что Docker Desktop запущен и установлен JDK 21.
2.  Клонируйте репозиторий: `git clone https://github.com/truestayhere/meeting-scheduler.git`
3.  Запустите PostgreSQL в Docker контейнере:
    ```bash
    docker run --name postgres-scheduler -e POSTGRES_DB=meeting_scheduler_db -e POSTGRES_USER=meeting_scheduler_db_user -e POSTGRES_PASSWORD=password -p 5432:5432 -d postgres:15 
    ```
4. Установите переменные окружения в терминале или непосредственно в вашей IDE:
    ```bash
    export DB_URL="jdbc:postgresql://localhost:5432/meeting_scheduler_db"
    export DB_USER="meeting_scheduler_db_user"
    export DB_PASS="password"
    export JWT_SECRET_KEY="dev-secret-key-that-is-long-enough-for-hs256"
    ```
5.  Соберите и запустите приложение: `mvn spring-boot:run`
6.  В **отдельном терминале**, создайте первоначального администратора (дефолтный логин и пароль: 'admin@company.com', 'admin_password'):
    ```bash
    docker exec -it postgres-scheduler psql -U meeting_scheduler_db_user -d meeting_scheduler_db -c 'INSERT INTO attendee (name, email, password, role, version) VALUES (''Admin'', ''admin@company.com'', ''$2a$10$FPwi3h05XyTwWPDdD21hNOjs7Y5jPsWEChA0ztNdFHUjxbfkJ3QHS'', ''ADMIN'', 0);'
    ```
7. Откройте интерактивную API документацию (Swagger UI): [http://localhost:8080/swagger-ui.html](http://localhost:8080/swagger-ui.html)

## Установка и конфигурация

Этот раздел содержит инструкции по запуску и настройке приложения.

### Необходимое ПО

Убедитесь, что установлены и работают следующие компоненты:
*   **Git:** Для клонирования репозитория.
*   **JDK 21:** Проверьте версию с помощью `java --version`.
*   **Maven 3.9+:** Проверьте версию с помощью `mvn --version`.
*   **Docker Desktop:** Требуется для тестирования и развертывания приложения.

### Конфигурация БД

Для корректной работы приложения требуется правильно настроенная база данных PostgreSQL.

**Вариант 1: Локальная установка PostgreSQL**

Установите PostgreSQL локально и создайте отдельную базу данных и пользователя для приложения.
```sql
CREATE DATABASE meeting_scheduler_db;
CREATE USER scheduler_user WITH PASSWORD 'secure_password';
GRANT ALL PRIVILEGES ON DATABASE meeting_scheduler_db TO scheduler_user;
\c meeting_scheduler_db
GRANT ALL ON SCHEMA public TO scheduler_user;
```

**Вариант 2: PostgreSQL в Docker (рекомендуется для разработки)**

Этот подход обеспечивает изоляцию и простоту очистки, при этом сохраняя полную функциональность PostgreSQL.

```bash
docker run --name postgres-scheduler \
  -e POSTGRES_DB=meeting_scheduler_db \
  -e POSTGRES_USER=scheduler_user \
  -e POSTGRES_PASSWORD=secure_password \
  -p 5432:5432 \
  -d postgres:15
```

### Конфигурация переменных окружения

Приложение настраивается с помощью переменных окружения. Вы можете установить их в конфигурации запуска вашей IDE или в профиле командной оболочки.

- DB_URL: jdbc:postgresql://localhost:5432/meeting_scheduler_db
- DB_USER: scheduler_user
- DB_PASS: secure_password
- JWT_SECRET_KEY: Длинная, надёжная, случайная строка (например, development-secret-key-minimum-256-bits-long-12345)

### Создание первоначального администратора

Чтобы иметь возможность создавать новых пользователей, требуется доступ администратора. Поэтому при первой инициализации приложения необходимо создать пользователя с правами администратора непосредственно в базе данных.

Подключитесь к `meeting_scheduler_db` с помощью SQL-клиента и выполните следующую команду:
```sql
INSERT INTO attendee (name, email, password, role, version, working_start_time, working_end_time)
VALUES (
  'System Administrator',
  'admin@company.com',
  '$2a$10$3g5vDbAfsKueJc0x23tLh.iGAKtStHwPrlqHAnHk2P2pMvBv99dOS', 
  'ADMIN',
  0,
  '08:00:00',
  '18:00:00'
);
```

Хеш пароля соответствует `password123`, сгенерированному с помощью BCrypt со степенью сложности 10.

### Сборка и запуск

Для запуска приложения выполните следующие команды в терминале.

**Клонирование репозитория:**
```bash
git clone https://github.com/truestayhere/meeting-scheduler.git
cd meeting-scheduler
```
**Сборка с полным набором тестов:**
```bash
mvn clean install
```
**Запуск приложения:**
```bash
mvn spring-boot:run
```

Приложение запускается на порту 8080 по умолчанию.

## Контейнеризация (Docker)

### Сборка Docker-образа

Из корневой директории проекта выполните следующую команду для сборки Docker-образа. Она скомпилирует приложение, выполнит тесты и упакует его в контейнер `meeting-scheduler-api`.

```bash
docker build -t meeting-scheduler-api .
```

Поведение приложения управляется через Spring Profiles, которые активируются переменной окружения `SPRING_PROFILES_ACTIVE`. Учетные данные БД и ключ JWT также задаются через переменные окружения.

Перед запуском контейнера убедитесь, что база данных PostgreSQL работает.

### **Запуск в контексте разработки**

Эта команда подходит для тестирования. Активирует профиль `dev` для подробного логирования и подключается к локальной базе данных.

```bash
docker run --rm -p 8080:8080 \
  -e SPRING_PROFILES_ACTIVE="dev" \
  -e DB_URL="jdbc:postgresql://host.docker.internal:5432/meeting_scheduler_db" \
  -e DB_USER="your_db_username" \
  -e DB_PASS="your_db_password" \
  -e JWT_SECRET_KEY="a-secure-dev-key-that-is-long-and-random" \
  --name scheduler-dev-container \
  meeting-scheduler-api:latest
```

### Пример для продакшн-развертывания

Эта команда подходит для запуска контейнера в продакшн-среде. Активирует профиль `prod` для более безопасной работы с БД и запускает контейнер в фоновом режиме (укажите ваши переменные).

```bash
docker run -d --restart unless-stopped \
  -p 80:8080 \
  -e SPRING_PROFILES_ACTIVE="prod" \
  -e DB_URL="jdbc:postgresql://production-db-hostname:5432/prod_db" \
  -e DB_USER="prod_db_user" \
  -e DB_PASS="${PROD_DB_PASSWORD}" \
  -e JWT_SECRET_KEY="${PROD_JWT_SECRET}" \
  --name meeting-scheduler-prod \
  meeting-scheduler-api:latest
```

## Тестирование

**Модульные тесты:** На основе JUnit 5, сосредоточены на отдельных компонентах, которые работают изолированно с использованием Mockito. Эти тесты проверяют сложную бизнес-логику, такую как алгоритмы обнаружения конфликтов и расчеты доступности, не обращаясь к базе данных или HTTP-инфраструктуре.

**Интеграционные тесты:** Используют Testcontainers для запуска реальных экземпляров PostgreSQL, что позволяет тщательно проверить весь стек приложения — от уровня сервиса до базы данных.

**Интеграционные тесты безопасности:** Проверяют, правильно ли работает система разграничения доступа по ролям. Они также должны гарантировать, что учетные записи `USER` не имеют доступа к административным эндпоинтам и что аутентификация с помощью JWT является безопасной.

**Запуск тестов:**

Используйте эту команду для выполнения полного набора тестов с помощью Maven.
```bash
mvn clean test
```

## API документация

**Интерактивная документация:** [http://localhost:8080/swagger-ui.html](http://localhost:8080/swagger-ui.html)

Интерфейс Swagger UI предоставляет полный доступ к эндпоинтам, формату запросов/ответов и позволяет тестировать API прямо из браузера.

**Сырая спецификация:** [http://localhost:8080/v3/api-docs](http://localhost:8080/v3/api-docs)

Сырая спецификация OpenAPI позволяет генерировать клиентские библиотеки и интегрировать их с инструментами управления API.

**Аутентификация в документации:**

Swagger UI поддерживает JWT-аутентификацию. После получения токена через эндпоинт `/api/auth/token` нажмите кнопку "Authorize", и в поле значения вставьте токен (длинную строку символов без префикса "Bearer ").

## Сценарий использования

Представьте себе компанию, в которой офис-менеджер (администратор) занимается настройкой переговорных комнат и учетных записей пользователей. А менеджер проекта (пользователь) должен найти наиболее подходящее время для проведения адаптационной сессии нового сотрудника.

### Этап 1: Административная настройка

**Шаг 1: Аутентификация администратора**

Админ входит в систему, используя учетные данные.

```json
POST /api/auth/token
Content-Type: application/json

{ "email": "admin@company.com", "password": "password123" }
```

**Вывод(?):** Админ получает JWT-токен с правами администратора (ADMIN).

**Шаг 2: Управление локациями**

Админ настраивает две доступные переговорные: "Кабинет 101" и "Кабинет 204".

```json
POST /api/locations
Authorization: Bearer <admin_token>
Content-Type: application/json

{
  "name": "Кабинет 101", "capacity": 10,
  "workingStartTime": "08:00:00", "workingEndTime": "18:00:00"
}
```

(...первая локация, "Кабинет 101", создана с id: 1, вместимостью 10 человек и рабочим временем 8-18)

```json
POST /api/locations
Authorization: Bearer <admin_token>
Content-Type: application/json

{
  "name": "Кабинет 204", "capacity": 2,
  "workingStartTime": "08:00:00", "workingEndTime": "18:00:00"
}
```

(...и вторая локация, "Кабинет 204", также создана с id: 2, вместимостью 2 человека и рабочим временем 8-18)

**Шаг 3: Создание учетных записей пользователей**

Админ создает аккаунты для двух сотрудников, Ивана (менеджера проекта) и Жанны (нового сотрудника), с разным рабочими временем.

```json
POST /api/attendees
Authorization: Bearer <admin_token>
Content-Type: application/json

{
  "name": "Иван Иванов", "email": "ivan.ivanov@company.com", "password": "newPassword", "role": "USER",
  "workingStartTime": "09:00:00", "workingEndTime": "17:00:00"
}
```

(...Иван создан с id: 2)

```json
POST /api/attendees
Authorization: Bearer <admin_token>
Content-Type: application/json

{
  "name": "Жанна Попова", "email": "jane.popova@company.com", "password": "anotherPassword", "role": "USER",
  "workingStartTime": "10:00:00", "workingEndTime": "18:00:00"
}
```

(...Жанна создана с id: 3)

### Этап 2: Симуляция загруженного расписания

Чтобы сделать сценарий реалистичным, предположим, что у Жанны уже запланирована встреча на этот день. Ивану нужно найти время, которое не пересекается с ее текущим графиком.

**Шаг 4: Аутентификация пользователя**

Иван входит в систему, чтобы получить токен, используя свои учетные данные.

```json
POST /api/auth/token
Content-Type: application/json

{ "email": "john.doe@company.com", "password": "password123" }
```

**Ответ:** Иван получает JWT-токен с правами пользователя (USER).

**Шаг 5: Бронирование встречи для Жанны**

Иван бронирует встречу "Подготовка к презентации", в которой участвует только Жанна.

```json
POST /api/meetings
Authorization: Bearer <johns_token>
Content-Type: application/json

{
  "title": "Подготовка к презентации",
  "startTime": "2024-11-21T14:00:00",
  "endTime": "2024-11-21T15:00:00",
  "locationId": 1,
  "attendeeIds": [3]
}
```

Эта встреча занимает ее график с 14:00 до 15:00.

### Этап 3: Интеллектуальное планирование

Теперь Ивану нужно запланировать часовую адаптационную сессию с Жанной. Он использует функции приложения по подбору времени.

**Шаг 6: Поиск подходящего времени**

Иван отправляет `POST`-запрос, указав детали встречи:

```json
POST /api/availability/suggestions
Authorization: Bearer <johns_token>
Content-Type: application/json

{
  "attendeeIds": [2, 3],
  "durationMinutes": 60,
  "date": "2024-11-21"
}
```

**Ожидаемый ответ (200 OK):**  
API анализирует расписание Ивана (9–17), Жанны (10–18) и уже существующие встречи, а затем предлагает все подходящие временные интервалы в доступных локациях.

```json
[
  {
    "location": {
      "id": 1,
      "name": "Кабинет 101",
      "capacity": 10
    },
    "availableSlot": {
      "startTime": "2024-11-21T10:00:00",
      "endTime": "2024-11-21T14:00:00"
    }
  },
  {
    "location": {
      "id": 2,
      "name": "Кабинет 204",
      "capacity": 2
    },
    "availableSlot": {
      "startTime": "2024-11-21T10:00:00",
      "endTime": "2024-11-21T14:00:00"
    }
  },
  {
    "location": {
      "id": 1,
      "name": "Кабинет 101",
      "capacity": 10
    },
    "availableSlot": {
      "startTime": "2024-11-21T15:00:00",
      "endTime": "2024-11-21T17:00:00"
    }
  },
  {
    "location": {
      "id": 2,
      "name": "Кабинет 204",
      "capacity": 2
    },
    "availableSlot": {
      "startTime": "2024-11-21T15:00:00",
      "endTime": "2024-11-21T17:00:00"
    }
  }
]
```
### Этап 4: Бронирование предложенного слота

Обладая этой информацией, Иван может быть уверен, что сможет организовать встречу, которая подходит всем.

**Шаг 7: Создание встречи**

Иван выбирает временной интервал с 10:00 до 14:00 в Кабинете 101 из предложенных.

```json
POST /api/meetings
Authorization: Bearer <johns_token>
Content-Type: application/json

{
  "title": "Адаптационная сессия",
  "startTime": "2024-11-21T10:00:00",
  "endTime": "2024-11-21T11:00:00",
  "locationId": 1,
  "attendeeIds": [2, 3]
}
```

Встреча создана успешно, без конфликтов.
